import pgp from 'pg-promise';

import db from '@agung_dhewe/webapps/src/db.js'
import Api from '@agung_dhewe/webapps/src/api.js'
import sqlUtil from '@agung_dhewe/pgsqlc'
import context from '@agung_dhewe/webapps/src/context.js'  
import logger from '@agung_dhewe/webapps/src/logger.js'<% if (usesequencer) { %>
import { createSequencerDocument } from '@agung_dhewe/webapps/src/sequencerdoc.js' <% } %><% if (usesequencerline) { %>
import { createSequencerLine } from '@agung_dhewe/webapps/src/sequencerline.js' <% } %><% if (importbucket) { %>
import bucket from '@agung_dhewe/webapps/src/bucket.js'	<% } %>

import * as Extender from './extenders/<%= moduleName %>.apiext.js'

const moduleName = '<%= moduleName %>'
const headerSectionName = 'header'
const headerTableName = '<%= headerTableName %>' <% entitiesDetil.forEach(entity => { %>
const <%= entity.name %>TableName = '<%= entity.table %>'  <% }) %>	

// api: account
export default class extends Api {
	constructor(req, res, next) {
		super(req, res, next);
		Api.cekLogin(req)
	}


	// dipanggil dengan model snake syntax
	// contoh: header-list
	//         header-open-data
	async init(body) { return await <%= moduleName %>_init(this, body) }

	// header
	async headerList(body) { return await <%= moduleName %>_headerList(this, body) }
	async headerOpen(body) { return await <%= moduleName %>_headerOpen(this, body) }
	async headerUpdate(body) { return await <%= moduleName %>_headerUpdate(this, body)}
	async headerCreate(body) { return await <%= moduleName %>_headerCreate(this, body)}
	async headerDelete(body) { return await <%= moduleName %>_headerDelete(this, body) }
	
	<% entitiesDetil.forEach(entity => { %>
	// <%= entity.name %>	
	async <%= entity.name %>List(body) { return await <%= moduleName %>_<%= entity.name %>List(this, body) }
	async <%= entity.name %>Open(body) { return await <%= moduleName %>_<%= entity.name %>Open(this, body) }
	async <%= entity.name %>Update(body) { return await <%= moduleName %>_<%= entity.name %>Update(this, body)}
	async <%= entity.name %>Create(body) { return await <%= moduleName %>_<%= entity.name %>Create(this, body) }
	async <%= entity.name %>Delete(body) { return await <%= moduleName %>_<%= entity.name %>Delete(this, body) }
	async <%= entity.name %>DeleteRows(body) { return await <%= moduleName %>_<%= entity.name %>DeleteRows(this, body) }
	<% }) %>		
}	

// init module
async function <%= moduleName %>_init(self, body) {
	const req = self.req

	// set sid untuk session ini, diperlukan ini agar session aktif
	req.session.sid = req.sessionID

	try {
		// ambil data app dari database
		const sql = 'select apps_id, apps_url from core."apps"'
		const result = await db.any(sql)

		const appsUrls = {}
		for (let row of result) {
			appsUrls[row.apps_id] = {
				url: row.apps_url
			}
		}

		const initialData = {
			userId: req.session.user.userId,
			userName: req.session.user.userName,
			userFullname: req.session.userFullname,
			sid: req.session.sid ,
			notifierId: Api.generateNotifierId(moduleName, req.sessionID),
			notifierSocket: req.app.locals.appConfig.notifierSocket,
			appsUrls: appsUrls,
			setting: {}
		}
		
		if (typeof Extender.<%= moduleName %>_init === 'function') {
			// export async function <%= moduleName %>_init(self, initialData) {}
			await Extender.<%= moduleName %>_init(self, initialData)
		}

		return initialData
		
	} catch (err) {
		throw err
	}
}


// data logging
async function <%= moduleName %>_log(self, body, startTime, tablename, id, action, data={}, remark='') {
	const { source } = body
	const req = self.req
	const user_id = req.session.user.userId
	const user_name = req.session.user.userFullname
	const ipaddress = req.ip
	const metadata = JSON.stringify({...{source:source}, ...data})
	const endTime = process.hrtime.bigint();
	const executionTimeMs = Number((endTime - startTime) / 1_000_000n); // hasil dalam ms tanpa desimal
	
	const logdata = {id, user_id, user_name, moduleName, action, tablename, executionTimeMs, remark, metadata, ipaddress}
	const ret = await logger.log(logdata)
	return ret
}

<% if (importbucket) { %>
async function <%= moduleName %>_upload(self, data, files, detilName, id, fn_uploadSuccess) {
	const bucketname = '<%= moduleName %>'
	const docid = data.<%= headerPrimaryKey %>
	
	const uploads = files.map(async (file) => {
		const fieldname = file.fieldname
		const objectname = detilName=='header' ? `${docid}/${fieldname}` : `${docid}/${detilName}/${id}-${fieldname}`
		
		const metaData = {
			'Content-Type': file.mimetype,
			'X-Amz-Meta-document_id': docid,
			'X-Amz-Meta-fieldname': fieldname,
			'X-Amz-Meta-originalname': file.originalname,
		};

		if (detilName!='header') {
			metaData['X-Amz-Meta-document-rowid'] = id
		}


		// simpan di bucket
		await bucket.putObject(bucketname, objectname, file.buffer, metaData);

		// catat di log
		if (typeof fn_uploadSuccess==='function') {
			fn_uploadSuccess({
				originalname: file.originalname,
				mimetype: file.fieldname,
				size: file.size,
				bucketname,
				objectname
			})
		}
		return {fieldname, objectname};
	});

	const uploadedFiles = await Promise.all(uploads);
	return uploadedFiles
}
<% } %>

async function <%= moduleName %>_headerList(self, body) {
	const tablename = headerTableName
	const { criteria={}, limit=0, offset=0, columns=[], sort={} } = body
	const searchMap = {<% headerSearchMap.forEach(searchmap => { %>
		<%= searchmap.name %>: `<%- searchmap.data %>`,<% }) %>
	};

	try {
	
		// jika tidak ada default searchtext
		if (searchMap.searchtext===undefined) {
			throw new Error(`'searchtext' belum didefinisikan di searchMap`)	
		}
		

		// hilangkan criteria '' atau null
		for (var cname in criteria) {
			if (criteria[cname]==='' || criteria[cname]===null) {
				delete criteria[cname]
			}
		}

		const args = { db, criteria }

		// apabila ada keperluan untuk recompose criteria
		if (typeof Extender.headerListCriteria === 'function') {
			// export async function headerListCriteria(self, db, searchMap, criteria, sort, columns, args) {}
			await Extender.headerListCriteria(self, db, searchMap, criteria, sort, columns, args)
		}

		var max_rows = limit==0 ? 10 : limit
		const {whereClause, queryParams} = sqlUtil.createWhereClause(criteria, searchMap) 
		const sql = sqlUtil.createSqlSelect({tablename, columns, whereClause, sort, limit:max_rows+1, offset, queryParams})
		const rows = await db.any(sql, queryParams);

		
		var i = 0
		const data = []
		for (var row of rows) {
			i++
			if (i>max_rows) { break }

			<% headerFieldsLookup.forEach(lookup => { %>// lookup: <%= lookup.bindingDisplay %> dari field <%= lookup.bindingText %> pada table <%= lookup.table %> dimana (<%= lookup.table %>.<%= lookup.bindingValue %> = <%= headerTableName %>.<%=lookup.fieldname%>)
			{
				const { <%= lookup.bindingText %> } = await sqlUtil.lookupdb(db, '<%= lookup.table %>', '<%=lookup.bindingValue%>', row.<%=lookup.fieldname%>)
				row.<%= lookup.bindingDisplay %> = <%= lookup.bindingText %>
			}
			<% }) %>
			// pasang extender di sini
			if (typeof Extender.headerListRow === 'function') {
				// export async function headerListRow(self, row, args) {}
				await Extender.headerListRow(self, row, args)
			}

			data.push(row)
		}

		var nextoffset = null
		if (rows.length>max_rows) {
			nextoffset = offset+max_rows
		}

		return {
			criteria: criteria,
			limit:  max_rows,
			nextoffset: nextoffset,
			data: data
		}

	} catch (err) {
		throw err
	}
}

async function <%= moduleName %>_headerOpen(self, body) {
	const tablename = headerTableName

	try {
		const { id } = body 
		const criteria = { <%= headerPrimaryKey %>: id }
		const searchMap = { <%= headerPrimaryKey %>: `<%= headerPrimaryKey %> = \${<%= headerPrimaryKey %>}`}
		const {whereClause, queryParams} = sqlUtil.createWhereClause(criteria, searchMap) 
		const sql = sqlUtil.createSqlSelect({
			tablename: tablename, 
			columns:[], 
			whereClause, 
			sort:{}, 
			limit:0, 
			offset:0, 
			queryParams
		})
		const data = await db.one(sql, queryParams);
		if (data==null) { 
			throw new Error(`[${tablename}] data dengan id '${id}' tidak ditemukan`) 
		}	

		<% headerFieldsLookup.forEach(lookup => { %>// lookup: <%= lookup.bindingDisplay %> dari field <%= lookup.bindingText %> pada table <%= lookup.table %> dimana (<%= lookup.table %>.<%= lookup.bindingValue %> = <%= headerTableName %>.<%=lookup.fieldname%>)
		{
			const { <%= lookup.bindingText %> } = await sqlUtil.lookupdb(db, '<%= lookup.table %>', '<%=lookup.bindingValue%>', data.<%=lookup.fieldname%>)
			data.<%= lookup.bindingDisplay %> = <%= lookup.bindingText %>
		}
		<% }) %>

		// lookup data createby
		{
			const { user_fullname } = await sqlUtil.lookupdb(db, 'core.user', 'user_id', data._createby)
			data._createby = user_fullname ?? ''
		}

		// lookup data modifyby
		{
			const { user_fullname } = await sqlUtil.lookupdb(db, 'core.user', 'user_id', data._modifyby)
			data._modifyby = user_fullname ?? ''
		}
		
		// pasang extender untuk olah data
		// export async function headerOpen(self, db, data) {}
		if (typeof Extender.headerOpen === 'function') {
			// export async function headerOpen(self, db, data) {}
			await Extender.headerOpen(self, db, data)
		}

		return data
	} catch (err) {
		throw err
	}
}


async function <%= moduleName %>_headerCreate(self, body) {
	const { source='<%= moduleName %>', data={} } = body
	const req = self.req
	const user_id = req.session.user.userId
	const startTime = process.hrtime.bigint();
	const tablename = headerTableName

	try {

		// parse uploaded data
		const files = Api.parseUploadData(data, req.files)


		data._createby = user_id
		data._createdate = (new Date()).toISOString()

		const result = await db.tx(async tx=>{
			sqlUtil.connect(tx)

			<% if (usesequencer) { %>// buat sequencer document	
			const sequencer = createSequencerDocument(tx, { 
				COMPANY_CODE: req.app.locals.appConfig.COMPANY_CODE,
				blockLength: <%= identifierBlock %>,
				numberLength: <%= identifierLength %>,
			})

			if (typeof Extender.sequencerSetup === 'function') {
				// jika ada keperluan menambahkan code block/cluster di sequencer
				// dapat diimplementasikan di exterder sequencerSetup 
				// export async function sequencerSetup(self, tx, sequencer, data) {}
				await Extender.sequencerSetup(self, tx, sequencer, data)
			}

			<%if (yearly) { %>// generate data <%= identifierPrefix %> reset pertahun
			const seqdata = await sequencer.yearly('<%= identifierPrefix %>')<% } 
			else { 
			
			%>// generate data <%= identifierPrefix %> reset perbulan
			const seqdata = await sequencer.monthly('<%= identifierPrefix %>')<% } %>	
			data.<%= headerPrimaryKey %> = seqdata.id

			// apabila ada keperluan pengelohan data sebelum disimpan, lakukan di extender headerCreating
			if (typeof Extender.headerCreating === 'function') {
				// export async function headerCreating(self, tx, data, seqdata) {}
				await Extender.headerCreating(self, tx, data, seqdata)
			}			
			
			<% } else if (shortsequencer) { %>
			// buat short sequencer	
			const sequencer = createSequencerLine(tx, {})

			if (typeof Extender.sequencerSetup === 'function') {
				// jika ada keperluan menambahkan code block/cluster di sequencer
				// dapat diimplementasikan di exterder sequencerSetup 
				// export async function sequencerSetup(self, tx, sequencer, data) {}
				await Extender.sequencerSetup(self, tx, sequencer, data)
			}

			// generate short id untuk <%= identifierPrefix %> reset pertahun
			const seqdata = await sequencer.yearlyshort('<%= identifierPrefix %>')
			data.<%= headerPrimaryKey %> = seqdata.id

			// apabila ada keperluan pengelohan data sebelum disimpan, lakukan di extender headerCreating
			if (typeof Extender.headerCreating === 'function') {
				// export async function headerCreating(self, tx, data, seqdata)
				await Extender.headerCreating(self, tx, data, seqdata)
			}

			<% } else { %>	
			// apabila ada keperluan pengelohan data sebelum disimpan, lakukan di extender headerCreating
			if (typeof Extender.headerCreating === 'function') {
				// export async function headerCreating(self, tx, data) {}
				await Extender.headerCreating(self, tx, data)
			}<% } %>

			<% if (autoid) { 
			%><% if (usesequencer || shortsequencer) { %>const cmd = sqlUtil.createInsertCommand(tablename, data)<% } else { %>const cmd = sqlUtil.createInsertCommand(tablename, data, ['<%= headerPrimaryKey %>'])<% } %><% 
		    } else { %>const cmd = sqlUtil.createInsertCommand(tablename, data)<% } %>
			const ret = await cmd.execute(data)

			<% if (headerHasUpload) { %>
			// jika ada file yang diupload di header
			if (files!=null) {
				<%= moduleName %>_upload(self, ret, files, 'header', ret.<%= headerPrimaryKey %>,  (result)=>{
					<%= moduleName %>_log(self, body, startTime, tablename, ret.<%= headerPrimaryKey %>, 'UPLOAD FILE', result, `${result.originalname}`)
				})
			}
			<% } %>
			const logMetadata = {}

			// apabila ada keperluan pengelohan data setelah disimpan, lakukan di extender headerCreated
			if (typeof Extender.headerCreated === 'function') {
				// export async function headerCreated(self, tx, ret, data, logMetadata) {}
				await Extender.headerCreated(self, tx, ret, data, logMetadata)
			}

			// record log
			<%= moduleName %>_log(self, body, startTime, tablename, ret.<%= headerPrimaryKey %>, 'CREATE', logMetadata)

			return ret
		})

		return result
	} catch (err) {
		throw err
	}
}

async function <%= moduleName %>_headerUpdate(self, body) {
	const { source='<%= moduleName %>', data={} } = body
	const req = self.req
	const user_id = req.session.user.userId
	const startTime = process.hrtime.bigint()
	const tablename = headerTableName

	try {

		// parse uploaded data
		const files = Api.parseUploadData(data, req.files)


		data._modifyby = user_id
		data._modifydate = (new Date()).toISOString()

		const result = await db.tx(async tx=>{
			sqlUtil.connect(tx)


			// apabila ada keperluan pengelohan data sebelum disimpan, lakukan di extender headerCreating
			if (typeof Extender.headerUpdating === 'function') {
				// export async function headerUpdating(self, tx, data) {}
				await Extender.headerUpdating(self, tx, data)
			}

			// eksekusi update
			const cmd = sqlUtil.createUpdateCommand(tablename, data, ['<%= headerPrimaryKey %>'])
			const ret = await cmd.execute(data)

			<% if (headerHasUpload) { %>
			// jika ada file yang diupload di header
			if (files!=null) {
				<%= moduleName %>_upload(self, ret, files, 'header', ret.<%= headerPrimaryKey %>,  (result)=>{
					<%= moduleName %>_log(self, body, startTime, tablename, ret.<%= headerPrimaryKey %>, 'UPLOAD FILE', result, `${result.originalname}`)
				})
			}
			<% } %>
			const logMetadata = {}

			// apabila ada keperluan pengelohan data setelah disimpan, lakukan di extender headerCreated
			if (typeof Extender.headerUpdated === 'function') {
				// export async function headerUpdated(self, tx, ret, data, logMetadata) {}
				await Extender.headerUpdated(self, tx, ret, data, logMetadata)
			}			

			// record log
			<%= moduleName %>_log(self, body, startTime, tablename, data.<%= headerPrimaryKey %>, 'UPDATE')

			return ret
		})
		

		return result
	} catch (err) {
		throw err
	}
}


async function <%= moduleName %>_headerDelete(self, body) {
	const { source, id } = body
	const req = self.req
	const user_id = req.session.user.userId
	const startTime = process.hrtime.bigint()
	const tablename = headerTableName

	try {

		const deletedRow = await db.tx(async tx=>{
			sqlUtil.connect(tx)

			const dataToRemove = {<%= headerPrimaryKey %>: id}

			// apabila ada keperluan pengelohan data sebelum dihapus, lakukan di extender headerDeleting
			if (typeof Extender.headerDeleting === 'function') {
				// export async function headerDeleting(self, tx, dataToRemove) {}
				await Extender.headerDeleting(self, tx, dataToRemove)
			}

			<% if (entitiesDetil.length>0) { %>
			<% entitiesDetil.forEach(entity => { %>// hapus data <%= entity.name %>
			{
				const sql = `select * from ${<%= entity.name %>TableName} where <%= headerPrimaryKey %>=\${<%= headerPrimaryKey %>}`
				const rows = await tx.any(sql, dataToRemove)
				for (let row<%= entity.name %> of rows) {
					// apabila ada keperluan pengelohan data sebelum dihapus, lakukan di extender
					if (typeof Extender.<%= entity.name %>Deleting === 'function') {
						// export async function <%= entity.name %>Deleting(self, tx, row<%= entity.name %>, logMetadata) {}
						await Extender.<%= entity.name %>Deleting(self, tx, row<%= entity.name %>, logMetadata)
					}

					const param = {<%= entity.pk %>: row<%= entity.name %>.<%= entity.pk %>}
					const cmd = sqlUtil.createDeleteCommand(<%= entity.name %>TableName, ['<%= entity.pk %>'])
					const deletedRow = await cmd.execute(param)

					// apabila ada keperluan pengelohan data setelah dihapus, lakukan di extender
					if (typeof Extender.<%= entity.name %>Deleted === 'function') {
						// export async function <%= entity.name %>Deleted(self, tx, deletedRow, logMetadata) {}
						await Extender.<%= entity.name %>Deleted(self, tx, deletedRow, logMetadata)
					}					

					<%= moduleName %>_log(self, body, startTime, <%= entity.name %>TableName, row<%= entity.name %>.<%= entity.pk %>, 'DELETE', {rowdata: deletedRow})
					<%= moduleName %>_log(self, body, startTime, headerTableName, row<%= entity.name %>.<%= headerPrimaryKey %>, 'DELETE ROW <%= entity.name.toUpperCase() %>', {<%= entity.pk %>: row<%= entity.name %>.<%= entity.pk %>, tablename: <%= entity.name %>TableName}, `removed: ${row<%= entity.name %>.<%= entity.pk %>}`)


				}	
			}

			<% }) %>
			<% } %>

			// hapus data header
			const cmd = sqlUtil.createDeleteCommand(tablename, ['<%= headerPrimaryKey %>'])
			const deletedRow = await cmd.execute(dataToRemove)

			const logMetadata = {}

			// apabila ada keperluan pengelohan data setelah dihapus, lakukan di extender headerDeleted
			if (typeof Extender.headerDeleted === 'function') {
				// export async function headerDeleted(self, tx, ret, logMetadata) {}
				await Extender.headerDeleted(self, tx, ret, logMetadata)
			}

			// record log
			<%= moduleName %>_log(self, body, startTime, tablename, id, 'DELETE', logMetadata)

			return deletedRow
		})
	

		return deletedRow
	} catch (err) {
		throw err
	}
}


<% entitiesDetil.forEach(entity => { %>
// <%= entity.name %>	

async function <%= moduleName %>_<%= entity.name %>List(self, body) {
	const tablename = <%= entity.name %>TableName
	const { criteria={}, limit=0, offset=0, columns=[], sort={} } = body
	const searchMap = {
		<%= headerPrimaryKey %>: `<%= headerPrimaryKey %>=try_cast_bigint(\${<%= headerPrimaryKey %>}, 0)`,
	};


	try {
	
		// hilangkan criteria '' atau null
		for (var cname in criteria) {
			if (criteria[cname]==='' || criteria[cname]===null) {
				delete criteria[cname]
			}
		}

		const args = { db, criteria }

		// apabila ada keperluan untuk recompose criteria
		if (typeof Extender.<%= entity.name %>ListCriteria === 'function') {
			// export async function <%= entity.name %>ListCriteria(self, db, searchMap, criteria, sort, columns, args) {}
			await Extender.<%= entity.name %>ListCriteria(self, db, searchMap, criteria, sort, columns, args)
		}

		var max_rows = limit==0 ? 10 : limit
		const {whereClause, queryParams} = sqlUtil.createWhereClause(criteria, searchMap) 
		const sql = sqlUtil.createSqlSelect({tablename, columns, whereClause, sort, limit:max_rows+1, offset, queryParams})
		const rows = await db.any(sql, queryParams);

		
		var i = 0
		const data = []
		for (var row of rows) {
			i++
			if (i>max_rows) { break }

			<% entity.fieldsLookup.forEach(lookup => { %>// lookup: <%= lookup.bindingDisplay %> dari field <%= lookup.bindingText %> pada table <%= lookup.table %> dimana (<%= lookup.table %>.<%= lookup.bindingValue %> = <%= headerTableName %>.<%=lookup.fieldname%>)
			{
				const { <%= lookup.bindingText %> } = await sqlUtil.lookupdb(db, '<%= lookup.table %>', '<%=lookup.bindingValue%>', row.<%=lookup.fieldname%>)
				row.<%= lookup.bindingDisplay %> = <%= lookup.bindingText %>
			}
			<% }) %>

			// pasang extender di sini
			if (typeof Extender.detilListRow === 'function') {
				// export async function detilListRow(self, row, args) {}
				await Extender.detilListRow(self, row, args)
			}

			data.push(row)
		}

		var nextoffset = null
		if (rows.length>max_rows) {
			nextoffset = offset+max_rows
		}

		return {
			criteria: criteria,
			limit:  max_rows,
			nextoffset: nextoffset,
			data: data
		}

	} catch (err) {
		throw err
	}
}

async function <%= moduleName %>_<%= entity.name %>Open(self, body) {
	const tablename = <%= entity.name %>TableName

	try {
		const { id } = body 
		const criteria = { <%= entity.pk %>: id }
		const searchMap = { <%= entity.pk %>: `<%= entity.pk %> = \${<%= entity.pk %>}`}
		const {whereClause, queryParams} = sqlUtil.createWhereClause(criteria, searchMap) 
		const sql = sqlUtil.createSqlSelect({
			tablename, 
			columns:[], 
			whereClause, 
			sort:{}, 
			limit:0, 
			offset:0, 
			queryParams
		})
		const data = await db.one(sql, queryParams);
		if (data==null) { 
			throw new Error(`[${tablename}] data dengan id '${id}' tidak ditemukan`) 
		}	


		<% entity.fieldsLookup.forEach(lookup => { %>// lookup: <%= lookup.bindingDisplay %> dari field <%= lookup.bindingText %> pada table <%= lookup.table %> dimana (<%= lookup.table %>.<%= lookup.bindingValue %> = <%= headerTableName %>.<%=lookup.fieldname%>)
		{
			const { <%= lookup.bindingText %> } = await sqlUtil.lookupdb(db, '<%= lookup.table %>', '<%=lookup.bindingValue%>', data.<%=lookup.fieldname%>)
			data.<%= lookup.bindingDisplay %> = <%= lookup.bindingText %>
		}
		<% }) %>

		// lookup data createby
		{
			const { user_fullname } = await sqlUtil.lookupdb(db, 'core.user', 'user_id', data._createby)
			data._createby = user_fullname ?? ''
		}

		// lookup data modifyby
		{
			const { user_fullname } = await sqlUtil.lookupdb(db, 'core.user', 'user_id', data._modifyby)
			data._modifyby = user_fullname ?? ''
		}	

		return data
	} catch (err) {
		throw err
	}
}

async function <%= moduleName %>_<%= entity.name %>Create(self, body) {
	const { source='<%= moduleName %>', data={} } = body
	const req = self.req
	const user_id = req.session.user.userId
	const startTime = process.hrtime.bigint();
	const tablename = <%= entity.name %>TableName

	try {

		// parse uploaded data
		const files = Api.parseUploadData(data, req.files)


		data._createby = user_id
		data._createdate = (new Date()).toISOString()

		const result = await db.tx(async tx=>{
			sqlUtil.connect(tx)

			const sequencer = createSequencerLine(tx, {})
			const seqdata = await sequencer.increment('<%= identifierPrefix %>')
			data.<%= entity.pk %> = seqdata.id

			// apabila ada keperluan pengolahan data SEBELUM disimpan
			if (typeof Extender.<%= entity.name %>Creating === 'function') {
				// export async function <%= entity.name %>Creating(self, tx, data, seqdata) {}
				await Extender.<%= entity.name %>Creating(self, tx, data, seqdata)
			}

			const cmd = sqlUtil.createInsertCommand(tablename, data)
			const ret = await cmd.execute(data)
			<% if (entity.detilHasUpload) { %>
			// jika ada file yang diupload di <%= entity.name %>
			if (files!=null) {
				<%= moduleName %>_upload(self, ret, files, '<%= entity.name %>', ret.<%= entity.pk %>,  (result)=>{
					<%= moduleName %>_log(self, body, startTime, tablename, ret.<%= entity.pk %>, 'UPLOAD FILE', result, `${result.originalname}`)
				})
			}
			<% } %>
			const logMetadata = {}

			// apabila ada keperluan pengelohan data setelah disimpan, lakukan di extender headerCreated
			if (typeof Extender.<%= entity.name %>Created === 'function') {
				// export async function <%= entity.name %>Created(self, tx, ret, data, logMetadata) {}
				await Extender.<%= entity.name %>Created(self, tx, ret, data, logMetadata)
			}

			// record log
			<%= moduleName %>_log(self, body, startTime, tablename, ret.<%= entity.pk %>, 'CREATE', logMetadata)

			return ret
		})

		return result
	} catch (err) {
		throw err
	}
}

async function <%= moduleName %>_<%= entity.name %>Update(self, body) {
	const { source='<%= moduleName %>', data={} } = body
	const req = self.req
	const user_id = req.session.user.userId
	const startTime = process.hrtime.bigint()
	const tablename = <%= entity.name %>TableName

	try {

		// parse uploaded data
		const files = Api.parseUploadData(data, req.files)


		data._modifyby = user_id
		data._modifydate = (new Date()).toISOString()

		const result = await db.tx(async tx=>{
			sqlUtil.connect(tx)


			// apabila ada keperluan pengolahan data SEBELUM disimpan
			if (typeof Extender.<%= entity.name %>Updating === 'function') {
				// export async function <%= entity.name %>Updating(self, tx, data) {}
				await Extender.<%= entity.name %>Updating(self, tx, data)
			}			
			
			const cmd =  sqlUtil.createUpdateCommand(tablename, data, ['<%= entity.pk %>'])
			const ret = await cmd.execute(data)
			<% if (entity.detilHasUpload) { %>
			// jika ada file yang diupload di <%= entity.name %>
			if (files!=null) {
				<%= moduleName %>_upload(self, ret, files, '<%= entity.name %>', ret.<%= entity.pk %>,  (result)=>{
					<%= moduleName %>_log(self, body, startTime, tablename, ret.<%= entity.pk %>, 'UPLOAD FILE', result, `${result.originalname}`)
				})
			}
			<% } %>
			const logMetadata = {}

			// apabila ada keperluan pengelohan data setelah disimpan, lakukan di extender headerCreated
			if (typeof Extender.<%= entity.name %>Updated === 'function') {
				// export async function <%= entity.name %>Updated(self, tx, ret, data, logMetadata) {}
				await Extender.<%= entity.name %>Updated(self, tx, ret, data, logMetadata)
			}

			// record log
			<%= moduleName %>_log(self, body, startTime, tablename, data.<%= entity.pk %>, 'UPDATE', logMetadata)

			return ret
		})
	
		return result
	} catch (err) {
		throw err
	}
}

async function <%= moduleName %>_<%= entity.name %>Delete(self, body) {
	const { source, id } = body 
	const req = self.req
	const user_id = req.session.user.userId
	const startTime = process.hrtime.bigint()
	const tablename = <%= entity.name %>TableName

	try {

		const deletedRow = await db.tx(async tx=>{
			sqlUtil.connect(tx)

			const dataToRemove = {<%= entity.pk %>: id}
			const sql = `select * from ${<%= entity.name %>TableName} where <%= entity.pk %>=\${<%= entity.pk %>}`
			const row<%= entity.name %> = await tx.oneOrNone(sql, dataToRemove)


			// apabila ada keperluan pengelohan data sebelum dihapus, lakukan di extender
			if (typeof Extender.<%= entity.name %>Deleting === 'function') {
				// export async function <%= entity.name %>Deleting(self, tx, row<%= entity.name %>, logMetadata) {}
				await Extender.<%= entity.name %>Deleting(self, tx, row<%= entity.name %>, logMetadata)
			}

			const param = {<%= entity.pk %>: row<%= entity.name %>.<%= entity.pk %>}
			const cmd = sqlUtil.createDeleteCommand(<%= entity.name %>TableName, ['<%= entity.pk %>'])
			const deletedRow = await cmd.execute(param)

			// apabila ada keperluan pengelohan data setelah dihapus, lakukan di extender
			if (typeof Extender.<%= entity.name %>Deleted === 'function') {
				// export async function <%= entity.name %>Deleted(self, tx, deletedRow, logMetadata) {}
				await Extender.<%= entity.name %>Deleted(self, tx, deletedRow, logMetadata)
			}					

			<%= moduleName %>_log(self, body, startTime, <%= entity.name %>TableName, row<%= entity.name %>.<%= entity.pk %>, 'DELETE', {rowdata: deletedRow})
			<%= moduleName %>_log(self, body, startTime, headerTableName, row<%= entity.name %>.<%= headerPrimaryKey %>, 'DELETE ROW <%= entity.name.toUpperCase() %>', {<%= entity.pk %>: row<%= entity.name %>.<%= entity.pk %>, tablename: <%= entity.name %>TableName}, `removed: ${row<%= entity.name %>.<%= entity.pk %>}`)

			return deletedRow
		})
	

		return deletedRow
	} catch (err) {
		throw err
	}
}

async function <%= moduleName %>_<%= entity.name %>DeleteRows(self, body) {
	const { data } = body 
	const req = self.req
	const user_id = req.session.user.userId
	const startTime = process.hrtime.bigint();
	const tablename = <%= entity.name %>TableName


	try {
		const result = await db.tx(async tx=>{
			sqlUtil.connect(tx)

			for (let id of data) {
				const dataToRemove = {<%= entity.pk %>: id}
				const sql = `select * from ${<%= entity.name %>TableName} where <%= entity.pk %>=\${<%= entity.pk %>}`
				const row<%= entity.name %> = await tx.oneOrNone(sql, dataToRemove)

				// apabila ada keperluan pengelohan data sebelum dihapus, lakukan di extender
				if (typeof Extender.<%= entity.name %>Deleting === 'function') {
					// async function <%= entity.name %>Deleting(self, tx, row<%= entity.name %>, logMetadata) {}
					await Extender.<%= entity.name %>Deleting(self, tx, row<%= entity.name %>, logMetadata)
				}

				const param = {<%= entity.pk %>: row<%= entity.name %>.<%= entity.pk %>}
				const cmd = sqlUtil.createDeleteCommand(<%= entity.name %>TableName, ['<%= entity.pk %>'])
				const deletedRow = await cmd.execute(param)

				// apabila ada keperluan pengelohan data setelah dihapus, lakukan di extender
				if (typeof Extender.<%= entity.name %>Deleted === 'function') {
					// export async function <%= entity.name %>Deleted(self, tx, deletedRow, logMetadata) {}
					await Extender.<%= entity.name %>Deleted(self, tx, deletedRow, logMetadata)
				}					

				<%= moduleName %>_log(self, body, startTime, <%= entity.name %>TableName, row<%= entity.name %>.<%= entity.pk %>, 'DELETE', {rowdata: deletedRow})
				<%= moduleName %>_log(self, body, startTime, headerTableName, row<%= entity.name %>.<%= headerPrimaryKey %>, 'DELETE ROW <%= entity.name.toUpperCase() %>', {<%= entity.pk %>: row<%= entity.name %>.<%= entity.pk %>, tablename: <%= entity.name %>TableName}, `removed: ${row<%= entity.name %>.<%= entity.pk %>}`)
			}
		})

		const res = {
			deleted: true,
			message: ''
		}
		return res
	} catch (err) {
		throw err
	}	
}

<% }) %>	